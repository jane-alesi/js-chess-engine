# JS Chess Engine - AI Agent Development Guide

## Project Overview

This is a pure JavaScript chess engine inspired by the legendary Atari Video Chess program. The project implements a complete chess game with AI opponent using modern JavaScript practices while honoring the efficient design principles of the original 6502 assembly implementation.

**Repository**: https://github.com/jane-alesi/js-chess-engine
**License**: MIT
**Target**: Browser-based chess game with AI opponent
**Architecture**: Modular, divide-and-conquer approach

## Project Goals

1. **Pure JavaScript Implementation**: No external chess libraries, complete from-scratch implementation
2. **AI Opponent**: Minimax algorithm with alpha-beta pruning, inspired by Video Chess AI techniques
3. **Modern Web Standards**: ES6+ modules, responsive design, accessibility
4. **Educational Value**: Clear, well-documented code for learning chess programming
5. **Performance**: Efficient algorithms suitable for real-time gameplay

## Architecture Overview

### Core Modules

```
src/
├── core/
│   ├── Board.js           # Board representation and state management
│   ├── Piece.js           # Piece definitions and movement rules
│   ├── GameState.js       # Game state, turns, check/checkmate detection
│   ├── MoveGenerator.js   # Legal move generation for all pieces
│   ├── MoveValidator.js   # Move validation and self-check prevention
│   └── Rules.js           # Chess rules implementation (castling, en passant, etc.)
├── ui/
│   ├── BoardRenderer.js   # Visual board rendering
│   ├── InputHandler.js    # User input processing
│   ├── UIController.js    # UI state management
│   └── Themes.js          # Visual themes and styling
├── ai/
│   ├── AIPlayer.js        # Main AI controller
│   ├── Evaluation.js      # Position evaluation function
│   ├── Search.js          # Minimax with alpha-beta pruning
│   └── OpeningBook.js     # Basic opening moves database
└── utils/
    ├── Notation.js        # Algebraic notation conversion
    ├── FEN.js             # FEN string parsing/generation
    ├── PGN.js             # PGN game notation support
    └── Constants.js       # Game constants and piece values
```

### Key Design Principles

1. **Separation of Concerns**: Clear boundaries between game logic, UI, and AI
2. **Immutable State**: Game state changes through pure functions where possible
3. **Event-Driven**: UI updates through event system
4. **Testable**: Each module designed for unit testing
5. **Extensible**: Plugin architecture for AI improvements and UI themes

## Automated Code Quality & Linting for LLMs

### 🎯 **Critical Importance for AI-Generated Code**

LLM-generated code must pass automated quality checks to prevent CI/CD pipeline failures. This section provides comprehensive guidelines for ensuring code quality before committing.

### 🔧 **Pre-Generation Code Quality Checklist**

Before generating any code, LLMs must consider:

1. **ESLint Compliance**: All code must pass ESLint rules without errors
2. **ES Module Compatibility**: Proper import/export syntax for ES6+ modules
3. **Jest Configuration**: Tests must be compatible with ES module setup
4. **Unused Variables**: Use underscore prefix for intentionally unused parameters
5. **Regex Escaping**: Avoid unnecessary escape characters in regular expressions

### 🚀 **Automated Linting Workflow**

#### **Phase 1: Pre-Commit Validation**

```bash
# Recommended pre-commit workflow
npm run lint          # Check for ESLint errors
npm run lint:fix       # Auto-fix ESLint issues
npm test              # Verify all tests pass
npm run format        # Apply Prettier formatting
```

#### **Phase 2: LLM Code Generation Best Practices**

1. **Parameter Naming Convention**:
   ```javascript
   // ✅ CORRECT: Unused parameters with underscore prefix
   function generateMoves(_piece, _position) {
       // TODO: Implement move generation
       return [];
   }
   
   // ❌ INCORRECT: Unused parameters without prefix
   function generateMoves(piece, position) {
       // TODO: Implement move generation
       return [];
   }
   ```

2. **ES Module Import/Export**:
   ```javascript
   // ✅ CORRECT: Proper ES module syntax
   import { Board } from '../../src/core/Board.js';
   export class MoveGenerator { }
   
   // ❌ INCORRECT: Wrong relative paths
   import { Board } from '../src/core/Board.js';
   ```

3. **Jest Configuration for ES Modules**:
   ```javascript
   // ✅ CORRECT: Jest config for ES modules
   const config = {
       testEnvironment: 'node',
       // NO extensionsToTreatAsEsm needed with "type": "module"
       moduleNameMapper: {
           '^(\\.{1,2}/.*)\\.js$': '$1'
       }
   };
   ```

4. **Regex Pattern Escaping**:
   ```javascript
   // ✅ CORRECT: Minimal necessary escaping
   moduleNameMapper: {
       '^(\\.{1,2}/.*)\\.js$': '$1'
   }
   
   // ❌ INCORRECT: Unnecessary escape characters
   moduleNameMapper: {
       '^(\\\\.{1,2}/.*)\\\\.js$': '$1'
   }
   ```

### 🛠️ **Common ESLint Error Patterns & Solutions**

#### **1. Unused Variables (no-unused-vars)**
```javascript
// ❌ Problem: ESLint error for unused parameters
function validateMove(fromPos, toPos, piece, gameState) {
    // Only using fromPos and toPos
    return fromPos >= 0 && toPos < 64;
}

// ✅ Solution: Prefix unused parameters with underscore
function validateMove(fromPos, toPos, _piece, _gameState) {
    return fromPos >= 0 && toPos < 64;
}
```

#### **2. Indentation Errors (indent)**
```javascript
// ❌ Problem: Inconsistent indentation in switch statements
switch (piece.type) {
        case 'pawn':
            return generatePawnMoves();
        case 'rook':
            return generateRookMoves();
}

// ✅ Solution: Consistent 4-space indentation
switch (piece.type) {
    case 'pawn':
        return generatePawnMoves();
    case 'rook':
        return generateRookMoves();
}
```

#### **3. Unnecessary Escape Characters (no-useless-escape)**
```javascript
// ❌ Problem: Unnecessary backslash escaping
const regex = /^(\\.{1,2}\/.*)\\.js$/;

// ✅ Solution: Remove unnecessary escapes
const regex = /^(\.{1,2}\/.*)\.js$/;
```

### 🔄 **Automated Fixing Strategies**

#### **Strategy 1: ESLint Auto-Fix**
```bash
# Auto-fix common issues
npx eslint . --fix

# Target specific files
npx eslint src/core/MoveGenerator.js --fix
```

#### **Strategy 2: Pre-Commit Hooks (Future Implementation)**
```json
// package.json - lint-staged configuration
{
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "prettier --write"
    ]
  }
}
```

#### **Strategy 3: LLM-Assisted Code Review**
1. **Generate Code**: Create initial implementation
2. **Self-Lint**: Run ESLint validation on generated code
3. **Auto-Fix**: Apply ESLint --fix for common issues
4. **Manual Review**: Address complex linting issues
5. **Test Validation**: Ensure all tests pass after fixes

### 📋 **LLM Code Generation Checklist**

Before submitting any code, verify:

- [ ] **ESLint Clean**: `npm run lint` passes without errors
- [ ] **Tests Pass**: `npm test` completes successfully  
- [ ] **Import Paths**: Correct relative paths for ES modules
- [ ] **Unused Parameters**: Prefixed with underscore if intentional
- [ ] **Jest Compatibility**: No ES module configuration conflicts
- [ ] **Regex Patterns**: No unnecessary escape characters
- [ ] **Indentation**: Consistent 4-space indentation
- [ ] **TODO Comments**: Clear implementation placeholders

### 🚨 **Critical CI/CD Failure Prevention**

Common failures and prevention:

1. **Jest Validation Errors**:
   - Remove `extensionsToTreatAsEsm: ['.js']` when using `"type": "module"`
   - Avoid invalid preset configurations

2. **Import Path Errors**:
   - Use correct relative paths: `../../src/core/Board.js`
   - Include `.js` extension for ES modules

3. **ESLint Rule Violations**:
   - Prefix unused parameters with underscore
   - Use consistent indentation (4 spaces)
   - Avoid unnecessary regex escaping

### 🔮 **Future Automated Linting Enhancements**

Planned improvements for LLM code generation:

1. **Pre-Commit Hooks**: Automatic ESLint fixing before commits
2. **LLM-Powered Linting**: AI-assisted code quality analysis
3. **Semantic Code Review**: Beyond syntax checking
4. **Auto-Commit Fixes**: Automatic commit of linting corrections
5. **Quality Gates**: Prevent commits with linting errors

## Development Guidelines

### Code Style

- **ES6+ Modules**: Use import/export syntax
- **Consistent Naming**: camelCase for variables/functions, PascalCase for classes
- **JSDoc Comments**: Document all public methods and complex logic
- **Error Handling**: Comprehensive error checking and user-friendly messages
- **Performance**: Optimize hot paths (move generation, evaluation)

### Testing Requirements

- **Unit Tests**: Jest framework for all core modules
- **Integration Tests**: Full game scenarios and AI behavior
- **Performance Tests**: Move generation and search algorithm benchmarks
- **Browser Tests**: Cross-browser compatibility verification

### Git Workflow

1. **Feature Branches**: Create branches for each issue/feature
2. **Descriptive Commits**: Clear commit messages explaining changes
3. **Pull Requests**: All changes through PR review process
4. **Issue Linking**: Link commits/PRs to relevant GitHub issues

## Key Files and Their Purposes

### Core Game Logic

- `src/core/Board.js`: 64-square array representation, piece placement, board state
- `src/core/Piece.js`: Piece types, movement patterns, capture rules
- `src/core/MoveGenerator.js`: Generate all legal moves for current position
- `src/core/MoveValidator.js`: Validate moves, prevent self-check situations
- `src/core/GameState.js`: Track game state, detect check/checkmate/stalemate

### User Interface

- `src/ui/BoardRenderer.js`: Canvas or DOM-based board visualization
- `src/ui/InputHandler.js`: Mouse/touch input for piece selection and movement
- `src/ui/UIController.js`: Coordinate between game logic and visual representation

### AI Implementation

- `src/ai/Search.js`: Minimax algorithm with alpha-beta pruning and quiescence search
- `src/ai/Evaluation.js`: Position evaluation considering material, mobility, safety
- `src/ai/AIPlayer.js`: AI move selection and difficulty levels

### Utilities

- `src/utils/Notation.js`: Convert between internal representation and algebraic notation
- `src/utils/FEN.js`: Import/export game positions using FEN notation
- `src/utils/Constants.js`: Piece values, board dimensions, game constants

## Issue-Driven Development Process

### Issue Categories

1. **Core Infrastructure** (Priority: Critical)
   - Board representation and basic piece movement
   - Game state management and rule enforcement
   - Move generation and validation systems

2. **User Interface** (Priority: High)
   - Board rendering and piece visualization
   - Input handling and move selection
   - Game controls and status display

3. **AI Implementation** (Priority: High)
   - Basic AI with random moves
   - Minimax search algorithm
   - Position evaluation function
   - Advanced AI features (opening book, endgame tables)

4. **Advanced Features** (Priority: Medium)
   - Game notation support (PGN, FEN)
   - Multiple difficulty levels
   - Game analysis and move history
   - Performance optimizations

5. **Polish and Testing** (Priority: Medium)
   - Comprehensive test suite
   - Cross-browser compatibility
   - Accessibility improvements
   - Documentation and examples

### Working with Issues

1. **Read Issue Carefully**: Understand requirements and acceptance criteria
2. **Check Dependencies**: Ensure prerequisite issues are complete
3. **Create Feature Branch**: Branch from main using issue number
4. **Implement Solution**: Follow coding standards and test requirements
5. **Update Tests**: Add/modify tests for new functionality
6. **Submit Pull Request**: Link to issue and provide clear description

## Technical Specifications

### Board Representation

- **1D Array**: 64-element array representing squares 0-63
- **Square Mapping**: a1=0, b1=1, ..., h8=63
- **Piece Encoding**: Objects with type, color, hasMoved properties
- **Empty Squares**: null values

### Move Representation

```javascript
{
  from: 12,           // Source square index
  to: 28,             // Destination square index
  piece: 'pawn',      // Moving piece type
  captured: 'knight', // Captured piece (if any)
  promotion: 'queen', // Promotion piece (if any)
  castling: 'kingside', // Castling type (if any)
  enPassant: true     // En passant capture flag
}
```

### Game State Structure

```javascript
{
  board: Array(64),         // Current board position
  currentPlayer: 'white',   // Active player
  castlingRights: {         // Castling availability
    white: { kingside: true, queenside: true },
    black: { kingside: true, queenside: true }
  },
  enPassantTarget: null,    // En passant target square
  halfmoveClock: 0,         // 50-move rule counter
  fullmoveNumber: 1,        // Game move counter
  gameStatus: 'active'      // active, check, checkmate, stalemate, draw
}
```

## AI Implementation Details

### Evaluation Function Components

1. **Material Balance**: Piece values (pawn=1, knight/bishop=3, rook=5, queen=9)
2. **Piece Mobility**: Number of legal moves available
3. **King Safety**: Proximity to enemy pieces, pawn shield
4. **Pawn Structure**: Doubled, isolated, passed pawns
5. **Center Control**: Piece placement in central squares

### Search Algorithm

- **Minimax**: Recursive game tree search
- **Alpha-Beta Pruning**: Eliminate unnecessary branches
- **Quiescence Search**: Extend search for tactical sequences
- **Iterative Deepening**: Gradually increase search depth
- **Move Ordering**: Search promising moves first

## Dependencies and Requirements

### Runtime Dependencies

- **None**: Pure JavaScript implementation
- **Browser Support**: Modern browsers with ES6+ support
- **Optional**: Web Workers for AI computation

### Development Dependencies

- **Jest**: Testing framework
- **ESLint**: Code linting
- **Prettier**: Code formatting
- **Webpack**: Module bundling (optional)
- **Live Server**: Development server

### Build Process

```bash
npm install          # Install dependencies
npm test             # Run test suite
npm run lint         # Check code style
npm run build        # Build production version
npm start            # Start development server
```

## Testing Strategy

### Unit Tests

- **Core Logic**: Board, pieces, move generation, validation
- **AI Components**: Evaluation function, search algorithm
- **Utilities**: Notation conversion, FEN parsing

### Integration Tests

- **Complete Games**: Play through full games programmatically
- **AI Behavior**: Verify AI makes reasonable moves
- **Edge Cases**: Unusual positions and rule interactions

### Performance Tests

- **Move Generation**: Benchmark legal move calculation
- **Search Speed**: Measure AI thinking time at various depths
- **Memory Usage**: Monitor object creation and garbage collection

## Contributing Guidelines for AI Agents

### Before Starting Work

1. **Read the Issue**: Understand requirements completely
2. **Check Dependencies**: Verify prerequisite work is complete
3. **Review Related Code**: Understand existing implementation patterns
4. **Plan Implementation**: Consider architecture and testing needs

### Implementation Process

1. **Create Feature Branch**: Use descriptive branch name with issue number
2. **Write Tests First**: TDD approach where appropriate
3. **Implement Feature**: Follow existing code patterns and style
4. **Update Documentation**: Modify README and comments as needed
5. **Test Thoroughly**: Ensure all tests pass and no regressions

### Code Quality Standards

- **Readability**: Clear variable names and logical structure
- **Documentation**: JSDoc comments for public APIs
- **Error Handling**: Graceful handling of invalid inputs
- **Performance**: Efficient algorithms for time-critical code
- **Compatibility**: Works across target browsers

### Pull Request Process

1. **Link to Issue**: Reference issue number in PR description
2. **Describe Changes**: Explain what was implemented and why
3. **Test Results**: Confirm all tests pass
4. **Breaking Changes**: Highlight any API changes
5. **Screenshots**: Include UI changes if applicable

## Deployment and Distribution

### Development Environment

- **Local Server**: Use live-server or similar for development
- **Hot Reload**: Automatic browser refresh on file changes
- **Debug Tools**: Browser developer tools for debugging

### Production Build

- **Minification**: Compress JavaScript for faster loading
- **Bundle**: Combine modules into single file if needed
- **Assets**: Optimize images and other resources
- **CDN**: Consider CDN deployment for better performance

### GitHub Pages Deployment

- **Automatic**: Deploy main branch to GitHub Pages
- **Demo**: Live demo available at github.io URL
- **Documentation**: Host project documentation alongside demo

## Troubleshooting Common Issues

### Move Generation Problems

- **Check Bounds**: Ensure moves stay within board boundaries
- **Piece Blocking**: Verify path-checking for sliding pieces
- **Self-Check**: Confirm moves don't leave own king in check

### AI Performance Issues

- **Search Depth**: Reduce depth if AI is too slow
- **Move Ordering**: Improve ordering for better pruning
- **Evaluation**: Optimize evaluation function for speed

### UI Responsiveness

- **Event Handling**: Ensure proper event listener management
- **Rendering**: Optimize drawing operations for smooth animation
- **Mobile**: Test touch input on mobile devices

## Resources and References

### Chess Programming

- **Chess Programming Wiki**: https://www.chessprogramming.org/
- **Video Chess Analysis**: https://nanochess.org/video_chess.html
- **Minimax Algorithm**: Standard game theory search algorithm
- **Alpha-Beta Pruning**: Search optimization technique

### JavaScript Best Practices

- **MDN Web Docs**: Comprehensive JavaScript reference
- **ES6+ Features**: Modern JavaScript language features
- **Testing with Jest**: Unit testing framework documentation
- **Performance Optimization**: Browser performance guidelines

### Game Development

- **Canvas API**: For advanced graphics rendering
- **Web Workers**: For background AI computation
- **Local Storage**: For saving game state and preferences
- **Responsive Design**: Mobile-friendly user interfaces

---

This document serves as the complete guide for AI agents working on the JS Chess Engine project. Follow these guidelines to ensure consistent, high-quality contributions that advance the project goals while maintaining code quality and architectural integrity.