# JS Chess Engine - Complete AI Agent Development Guide

## ğŸ“‹ Project Context Reference

**IMPORTANT**: For current project status, active issues, and development workflows specific to chat.satware.ai, see `llms_project_context.txt` in the repository root. This file contains dynamic project context and immediate priorities.

**This file (llms.txt)** provides comprehensive development guidelines for any LLM working on the project, while `llms_project_context.txt` focuses on current state and next steps.

## Project Overview

This is a pure JavaScript chess engine inspired by the legendary Atari Video Chess program. The project implements a complete chess game with an AI opponent using modern JavaScript practices while honoring the efficient design principles of the original 6502 assembly implementation.

**Repository**: https://github.com/jane-alesi/js-chess-engine
**License**: MIT
**Target**: Browser-based chess game with AI opponent
**Architecture**: Modular, divide-and-conquer approach

## ğŸ¯ Development Philosophy

### Core Principles
- **Issue-Driven Development** - All work tracked through GitHub Issues
- **Modular Architecture** - Core, UI, AI, Utils components with incremental development
- **AI-First Design** - Optimized for LLM collaboration and code generation
- **File-Reference Approach** - Reference actual repository files instead of embedding large code examples
- **ğŸ§¹ Clean Code Standards** - Self-documenting code without unnecessary comments
- **â™Ÿï¸ Official Chess Standards** - Strict adherence to standard chess notation and rules

### File Structure Overview

```
src/
â”œâ”€â”€ core/          # Chess logic (Board, Piece, Game)
â”‚   â”œâ”€â”€ Board.js              # Board representation and state management
â”‚   â”œâ”€â”€ Piece.js              # Piece definitions with ES2022 private fields
â”‚   â”œâ”€â”€ GameState.js          # Game state, turns, check/checkmate detection
â”‚   â”œâ”€â”€ MoveGenerator.js      # Legal move generation for all pieces
â”‚   â”œâ”€â”€ MoveValidator.js      # Move validation and self-check prevention
â”‚   â””â”€â”€ Rules.js              # Chess rules implementation
â”œâ”€â”€ ui/            # User interface
â”‚   â”œâ”€â”€ BoardRenderer.js      # Visual board rendering
â”‚   â”œâ”€â”€ InputHandler.js       # User input processing
â”‚   â”œâ”€â”€ UIController.js       # UI state management
â”‚   â””â”€â”€ styles.css            # Styling and themes
â”œâ”€â”€ ai/            # AI engine (Future implementation)
â”‚   â”œâ”€â”€ AIPlayer.js           # Main AI controller
â”‚   â”œâ”€â”€ Evaluation.js         # Position evaluation function
â”‚   â”œâ”€â”€ Search.js             # Minimax with alpha-beta pruning
â”‚   â””â”€â”€ OpeningBook.js        # Basic opening moves database
â””â”€â”€ utils/         # Utilities
    â”œâ”€â”€ Constants.js          # Game constants and piece values
    â”œâ”€â”€ Notation.js           # Algebraic notation conversion
    â”œâ”€â”€ FEN.js                # FEN string parsing/generation
    â””â”€â”€ PGN.js                # PGN game notation support
```

## ğŸ”§ Implementation Guidelines

### 1. Core Chess Logic

**Key Files to Reference:**
- `src/core/Board.js` - 64-square array representation with piece management
- `src/core/Piece.js` - ES2022 implementation with private fields and comprehensive validation
- `src/core/GameState.js` - Game state management including castling rights and move history
- `src/core/MoveGenerator.js` - Piece-specific move generation (pawn moves completed)

**Implementation Patterns:**
- Use ES2022 private fields for encapsulation
- Implement comprehensive input validation with descriptive errors
- Follow getter/setter patterns for private field access
- Maintain immutable game state for AI search
- **ğŸ§¹ Write self-documenting code without comments**
- **â™Ÿï¸ Follow standard chess notation (a1=56, h8=0)**

### 2. Move Generation System

**Current Status:**
- âœ… Pawn, Rook, Bishop, Knight, King and Queen moves fully implemented (see `src/core/MoveGenerator.js`)

**Move Object Structure:**
```javascript
const move = {
    from: 12,              // Source square index (0-63)
    to: 28,                // Destination square index
    type: 'normal',        // 'normal', 'double', 'capture', 'castling', 'enPassant'
    piece: 'pawn',         // Moving piece type
    color: 'white',        // Moving piece color
    captured: 'knight'     // Captured piece type (if any)
};
```

### 3. Testing Strategy

**Test Structure:**
```
tests/
â”œâ”€â”€ core/          # Core logic tests
â”œâ”€â”€ ui/            # UI component tests
â”œâ”€â”€ ai/            # AI engine tests
â””â”€â”€ integration/   # Integration tests
```

**Key Testing Principles:**
- Use getter methods for private field testing: `piece.getType()` not `piece.type`
- Test error conditions with descriptive error messages
- Update dependent tests when modifying core components
- Reference `tests/core/MoveGenerator.test.js` for comprehensive test patterns

### 4. Modern JavaScript Standards (2025)

**ES2022 Features:**
- Private class fields with `#` syntax
- Static class fields for constants
- Proper error handling with descriptive exceptions
- ES modules with explicit `.js` extensions

**Code Quality:**
- ESLint flat config with Prettier integration
- Automated linting pipeline prevents CI failures
- Jest configuration for ES modules
- Comprehensive error handling patterns
- **ğŸ§¹ Clean code principle: No comments, self-documenting code**
- **â™Ÿï¸ Standard chess notation compliance**

### 5. Clean Code Standards (CRITICAL)

**ğŸ§¹ Clean Code Principles:**
- **Remove unused variables entirely** - Never introduce unused variables, they are useless clutter
- **Follow .eslintrc.json standards strictly** - Project has strict no-unused-vars rule
- **Use parameterless catch blocks** when error details aren't needed: `catch { ... }` instead of `catch (error) { ... }`
- **Clean code over workarounds** - Remove unnecessary code rather than trying to work around ESLint
- **Self-documenting code** - Method names, variable names, and structure should make intent obvious
- **No comments** - Good code should not need comments to explain what it does

**Example Clean Code:**
```javascript
export class MoveValidator {
    isValidMove(fromPosition, toPosition) {
        try {
            if (!this.isValidPosition(fromPosition)) {
                return false;
            }
            
            const piece = this.board.squares[fromPosition];
            return this.validatePieceMovement(piece, fromPosition, toPosition);
        } catch {
            return false;
        }
    }
}
```

### 6. Chess Standards Compliance (CRITICAL)

**â™Ÿï¸ Standard Chess Notation:**
- **Board Layout**: Rank 1 = positions 56-63 (white back rank), Rank 8 = positions 0-7 (black back rank)
- **Pawn Movement**: White moves "up" (-8 direction), Black moves "down" (+8 direction)
- **Starting Positions**: White pawns rank 2 (48-55), Black pawns rank 7 (8-15)
- **Square Mapping**: a1=56, h1=63, a8=0, h8=7

**Board Representation:**
```
Rank 8 (0-7):   â™œâ™â™â™›â™šâ™â™â™œ  (a8-h8, Black back rank)
Rank 7 (8-15):  â™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿâ™Ÿ  (a7-h7, Black pawns)
Rank 6 (16-23): ........  (empty)
Rank 5 (24-31): ........  (empty)
Rank 4 (32-39): ........  (empty)
Rank 3 (40-47): ........  (empty)
Rank 2 (48-55): â™™â™™â™™â™™â™™â™™â™™â™™  (a2-h2, White pawns)
Rank 1 (56-63): â™–â™˜â™—â™•â™”â™—â™˜â™–  (a1-h1, White back rank)
```

## ğŸš€ Development Workflow

### Issue-Driven Development
1. **Read Issue Carefully**: Understand requirements and acceptance criteria
2. **Check Dependencies**: Ensure prerequisite issues are complete
3. **Reference Current Files**: Check actual implementation in repository
4. **Follow Coding Standards**: Use patterns from existing code
5. **Update Tests**: Maintain test compatibility with changes
6. **Submit Pull Request**: Link to issue with clear description

### Git Workflow Example
```bash
# Create feature branch
git checkout -b feature/issue-32-move-validation

# Reference existing files for patterns
# Implement following established conventions
# Run quality checks
npm run quality:check
npm test

# Commit with descriptive message
git commit -m "âœ¨ Implement move validation system (Issue #32)

- Add MoveValidator class following Board.js patterns
- Implement self-check prevention logic
- Add comprehensive unit tests
- Update documentation"
```

## â™Ÿï¸ Chess-Specific Implementation

### Board Representation
- 64-square array (0-63 indices)
- Square mapping: `a1=56, h1=63, a8=0, h8=7`
- Reference `src/utils/Constants.js` for piece positions and values

### Piece Movement Patterns
- Each piece type has specific movement vectors
- Validation includes board boundaries and piece-specific rules
- Reference `src/core/MoveGenerator.js` for implemented patterns

### Game Rules Implementation
- Standard chess rules with special moves (castling, en passant, promotion)
- Check/checkmate detection
- Move history and game state tracking

## ğŸ§ª Testing Best Practices

### Test Compatibility Protocol
When modifying core components:
1. **Identify dependent tests** before making changes
2. **Update tests** to use getter methods for private fields
3. **Run full test suite** to verify compatibility
4. **Document breaking changes** in commit messages

### Example Test Updates
```javascript
// âŒ INCORRECT: Direct property access
expect(piece.type).toBe('pawn');

// âœ… CORRECT: Use getter methods
expect(piece.getType()).toBe('pawn');
```

## ğŸ” Performance Considerations

### Optimization Strategies
- Efficient board representation for fast move generation
- Alpha-beta pruning for AI search
- Transposition tables for position caching
- Web Workers for non-blocking AI computation

### Memory Management
- Immutable game states for search
- Efficient piece representation
- Minimal object creation in hot paths

## ğŸ“š Key Resources

### Chess Programming
- **Chess Programming Wiki**: https://www.chessprogramming.org/
- **Video Chess Analysis**: https://nanochess.org/video_chess.html
- **Minimax Algorithm**: Standard game theory search algorithm

### JavaScript Best Practices
- **MDN Web Docs**: Comprehensive JavaScript reference
- **ES2022 Features**: Modern JavaScript language features
- **Testing with Jest**: Unit testing framework documentation

## ğŸ› ï¸ Troubleshooting Guide

### Common Issues

**1. ESLint/Prettier Conflicts**
- Solution: Project uses `eslint-config-prettier` to prevent conflicts
- Run `npm run quality:fix` for automated fixing

**2. Test Failures with Private Fields**
- Solution: Use getter methods (`piece.getType()`) instead of direct access
- Update dependent tests when modifying core components

**3. Module Resolution Errors**
- Solution: Ensure `"type": "module"` in `package.json`
- Use `.js` extensions in import paths

**4. Performance Issues**
- Solution: Implement alpha-beta pruning, transposition tables
- Use Web Workers for AI computation

**5. Clean Code Violations**
- Solution: Remove unused variables entirely, use parameterless catch blocks
- Follow strict no-unused-vars rule, write self-documenting code

**6. Chess Standards Violations**
- Solution: Follow standard chess notation (a1=56, h8=0)
- Ensure proper pawn movement directions and starting positions

### Development Environment
- Node.js with ES2022 support
- Jest with experimental VM modules
- ESLint 9.x with flat config
- Prettier for code formatting

## ğŸ¯ Implementation Priorities

### âœ… Phase 1: Documentation & Project Management (COMPLETED)
1. âœ… **Create Professional README.md** (#35) - Impactful header and project description
2. âœ… **Add Installation and Usage Sections** (#36) - Comprehensive setup instructions
3. âœ… **Add Architecture Diagram and Contribution Guidelines** (#37) - Mermaid diagrams and CONTRIBUTING.md
4. âœ… **Add Status Badges and Roadmap** (#38) - CI/CD transparency and development roadmap

**ğŸ“Š Documentation Achievement**: Complete professional documentation foundation (README.md: 16.9KB, CONTRIBUTING.md: 10.7KB)

### âœ… Phase 2: Core Move Generation (COMPLETED)
- âœ… **Pawn, Rook, Bishop, Knight, King and Queen moves fully implemented**
- **All pseudo-legal move generation for standard pieces is now implemented.**

### ğŸ”§ Phase 3: Core Game Logic (CURRENT PRIORITY)
1. **Issue #15**: Enhance Board.js movePiece for Game Logic (**COMPLETED**)
2. **Issue #49**: Fix MoveValidator integration (**COMPLETED**)
3. **ğŸ§¹ Clean Code Implementation**: Remove comments, follow standards (**COMPLETED**)
4. **â™Ÿï¸ Chess Standards Compliance**: Standard notation implementation (**COMPLETED**)
5. **Issue #14**: Orchestrate Game Flow with Game Class (**NEXT RECOMMENDED**)

### ğŸ§  Phase 4: AI Implementation (Lower Priority)
1. Basic AI with random moves
2. Minimax search algorithm
3. Position evaluation function
4. Alpha-beta pruning optimization

### ğŸ¨ Phase 5: Advanced Features (Future)
1. Multiple difficulty levels
2. Opening book integration
3. Performance optimizations
4. Advanced UI features

---

## ğŸ“‹ Documentation & Project Management

### Professional Documentation Complete âœ…

The project now features world-class documentation including:

**README.md (16.9KB)**
- Professional header with dynamic status badges
- Comprehensive project description and vision
- Complete installation and usage instructions
- Mermaid.js architecture diagram
- 6-phase development roadmap with progress tracking
- Professional presentation suitable for portfolio use

**CONTRIBUTING.md (10.7KB)**
- Comprehensive contribution guidelines for humans and AI agents
- Issue-driven development workflow
- ES2022 technical standards and testing protocols
- Code quality gates and automation
- Pull request process with templates
- Security guidelines and best practices

**Enhanced Project Credibility**
- 8 dynamic status badges providing real-time project health
- Clear development direction through structured roadmap
- Complete onboarding experience for new contributors
- Professional presentation enhancing trust and adoption

### Issue Templates & Automation

**Next Documentation Priorities:**
1. **Issue #39**: Create Standardized GitHub Issue Templates
2. **Issue #40**: Implement Intelligent Issue Labeling and Automation

These will complete the project management infrastructure for efficient scaling.

---

This document serves as the comprehensive development guide for any LLM working on the JS Chess Engine project. Always reference actual repository files for current implementation details and use `llms_project_context.txt` for current project status and immediate priorities.

**Remember**: This guide focuses on HOW to develop, while `llms_project_context.txt` focuses on WHAT to develop next.

**Current Status**: Core Game Logic Phase (Phase 3) â†’ Enhanced with clean code standards and chess notation compliance