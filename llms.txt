# JS Chess Engine - Complete AI Agent Development Guide

## 📋 Project Context Reference

**IMPORTANT**: For current project status, active issues, and development workflows specific to chat.satware.ai, see `llms_project_context.txt` in the repository root. This file contains dynamic project context and immediate priorities.

**This file (llms.txt)** provides comprehensive development guidelines for any LLM working on the project, while `llms_project_context.txt` focuses on current state and next steps.

## Project Overview

This is a pure JavaScript chess engine inspired by the legendary Atari Video Chess program. The project implements a complete chess game with an AI opponent using modern JavaScript practices while honoring the efficient design principles of the original 6502 assembly implementation.

**Repository**: https://github.com/jane-alesi/js-chess-engine
**License**: MIT
**Target**: Browser-based chess game with AI opponent
**Architecture**: Modular, divide-and-conquer approach

## 🎯 Development Philosophy

### Core Principles
- **Issue-Driven Development** - All work tracked through GitHub Issues
- **Modular Architecture** - Core, UI, AI, Utils components with incremental development
- **AI-First Design** - Optimized for LLM collaboration and code generation
- **File-Reference Approach** - Reference actual repository files instead of embedding large code examples

### File Structure Overview

```
src/
├── core/          # Chess logic (Board, Piece, Game)
│   ├── Board.js              # Board representation and state management
│   ├── Piece.js              # Piece definitions with ES2022 private fields
│   ├── GameState.js          # Game state, turns, check/checkmate detection
│   ├── MoveGenerator.js      # Legal move generation for all pieces
│   ├── MoveValidator.js      # Move validation and self-check prevention
│   └── Rules.js              # Chess rules implementation
├── ui/            # User interface
│   ├── BoardRenderer.js      # Visual board rendering
│   ├── InputHandler.js       # User input processing
│   ├── UIController.js       # UI state management
│   └── styles.css            # Styling and themes
├── ai/            # AI engine (Future implementation)
│   ├── AIPlayer.js           # Main AI controller
│   ├── Evaluation.js         # Position evaluation function
│   ├── Search.js             # Minimax with alpha-beta pruning
│   └── OpeningBook.js        # Basic opening moves database
└── utils/         # Utilities
    ├── Constants.js          # Game constants and piece values
    ├── Notation.js           # Algebraic notation conversion
    ├── FEN.js                # FEN string parsing/generation
    └── PGN.js                # PGN game notation support
```

## 🔧 Implementation Guidelines

### 1. Core Chess Logic

**Key Files to Reference:**
- `src/core/Board.js` - 64-square array representation with piece management
- `src/core/Piece.js` - ES2022 implementation with private fields and comprehensive validation
- `src/core/GameState.js` - Game state management including castling rights and move history
- `src/core/MoveGenerator.js` - Piece-specific move generation (pawn moves completed)

**Implementation Patterns:**
- Use ES2022 private fields for encapsulation
- Implement comprehensive input validation with descriptive errors
- Follow getter/setter patterns for private field access
- Maintain immutable game state for AI search

### 2. Move Generation System

**Current Status:**
- ✅ Pawn moves fully implemented (see `src/core/MoveGenerator.js`)
- 🔄 Other pieces: Rook, Bishop, Knight, King, Queen (see active issues)

**Move Object Structure:**
```javascript
const move = {
    from: 12,              // Source square index (0-63)
    to: 28,                // Destination square index
    type: 'normal',        // 'normal', 'double', 'capture', 'castling', 'enPassant'
    piece: 'pawn',         // Moving piece type
    color: 'white',        // Moving piece color
    captured: 'knight'     // Captured piece type (if any)
};
```

### 3. Testing Strategy

**Test Structure:**
```
tests/
├── core/          # Core logic tests
├── ui/            # UI component tests
├── ai/            # AI engine tests
└── integration/   # Integration tests
```

**Key Testing Principles:**
- Use getter methods for private field testing: `piece.getType()` not `piece.type`
- Test error conditions with descriptive error messages
- Update dependent tests when modifying core components
- Reference `tests/core/MoveGenerator.test.js` for comprehensive test patterns

### 4. Modern JavaScript Standards (2025)

**ES2022 Features:**
- Private class fields with `#` syntax
- Static class fields for constants
- Proper error handling with descriptive exceptions
- ES modules with explicit `.js` extensions

**Code Quality:**
- ESLint flat config with Prettier integration
- Automated linting pipeline prevents CI failures
- Jest configuration for ES modules
- Comprehensive error handling patterns

## 🚀 Development Workflow

### Issue-Driven Development
1. **Read Issue Carefully**: Understand requirements and acceptance criteria
2. **Check Dependencies**: Ensure prerequisite issues are complete
3. **Reference Current Files**: Check actual implementation in repository
4. **Follow Coding Standards**: Use patterns from existing code
5. **Update Tests**: Maintain test compatibility with changes
6. **Submit Pull Request**: Link to issue with clear description

### Git Workflow Example
```bash
# Create feature branch
git checkout -b feature/issue-32-move-validation

# Reference existing files for patterns
# Implement following established conventions
# Run quality checks
npm run quality:check
npm test

# Commit with descriptive message
git commit -m "✨ Implement move validation system (Issue #32)

- Add MoveValidator class following Board.js patterns
- Implement self-check prevention logic
- Add comprehensive unit tests
- Update documentation"
```

## 🎮 Chess-Specific Implementation

### Board Representation
- 64-square array (0-63 indices)
- Square mapping: `a1=56, h1=63, a8=0, h8=7`
- Reference `src/utils/Constants.js` for piece positions and values

### Piece Movement Patterns
- Each piece type has specific movement vectors
- Validation includes board boundaries and piece-specific rules
- Reference `src/core/MoveGenerator.js` for implemented patterns

### Game Rules Implementation
- Standard chess rules with special moves (castling, en passant, promotion)
- Check/checkmate detection
- Move history and game state tracking

## 🧪 Testing Best Practices

### Test Compatibility Protocol
When modifying core components:
1. **Identify dependent tests** before making changes
2. **Update tests** to use getter methods for private fields
3. **Run full test suite** to verify compatibility
4. **Document breaking changes** in commit messages

### Example Test Updates
```javascript
// ❌ INCORRECT: Direct property access
expect(piece.type).toBe('pawn');

// ✅ CORRECT: Use getter methods
expect(piece.getType()).toBe('pawn');
```

## 🔍 Performance Considerations

### Optimization Strategies
- Efficient board representation for fast move generation
- Alpha-beta pruning for AI search
- Transposition tables for position caching
- Web Workers for non-blocking AI computation

### Memory Management
- Immutable game states for search
- Efficient piece representation
- Minimal object creation in hot paths

## 📚 Key Resources

### Chess Programming
- **Chess Programming Wiki**: https://www.chessprogramming.org/
- **Video Chess Analysis**: https://nanochess.org/video_chess.html
- **Minimax Algorithm**: Standard game theory search algorithm

### JavaScript Best Practices
- **MDN Web Docs**: Comprehensive JavaScript reference
- **ES2022 Features**: Modern JavaScript language features
- **Testing with Jest**: Unit testing framework documentation

## 🛠️ Troubleshooting Guide

### Common Issues

**1. ESLint/Prettier Conflicts**
- Solution: Project uses `eslint-config-prettier` to prevent conflicts
- Run `npm run quality:fix` for automated fixing

**2. Test Failures with Private Fields**
- Solution: Use getter methods (`piece.getType()`) instead of direct access
- Update dependent tests when modifying core components

**3. Module Resolution Errors**
- Solution: Ensure `"type": "module"` in `package.json`
- Use `.js` extensions in import paths

**4. Performance Issues**
- Solution: Implement alpha-beta pruning, transposition tables
- Use Web Workers for AI computation

### Development Environment
- Node.js with ES2022 support
- Jest with experimental VM modules
- ESLint 9.x with flat config
- Prettier for code formatting

## 🎯 Implementation Priorities

### Phase 1: Core Foundation (Critical)
1. Complete move generation for all pieces (Issues #1, #2, #6, #7, #9)
2. Implement move validation and legal move filtering
3. Add check/checkmate detection
4. Complete game state management

### Phase 2: Documentation & Project Management (High Priority)
1.  **Create Professional README.md** (#35, #36, #37, #38)
2.  **Implement Issue Templates** (#39)
3.  **Implement Labeling & Automation** (#40)

### Phase 3: AI Implementation (Medium Priority)
1. Basic AI with random moves
2. Minimax search algorithm
3. Position evaluation function
4. Alpha-beta pruning optimization

### Phase 4: Advanced Features (Low Priority)
1. Multiple difficulty levels
2. Opening book integration
3. Performance optimizations
4. Advanced UI features

---

This document serves as the comprehensive development guide for any LLM working on the JS Chess Engine project. Always reference actual repository files for current implementation details and use `llms_project_context.txt` for current project status and immediate priorities.

**Remember**: This guide focuses on HOW to develop, while `llms_project_context.txt` focuses on WHAT to develop next.
